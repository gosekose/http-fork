# 커넥션 관리

<br>

## 4.1 TCP 커넥션

- 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이뤄짐
- 일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달
- 순서
    - https://www.jose.com:80/power.html
    - 브라우저가 www.jose.com라는 호스트 명을 추출
    - 브라우저가 호스트 명에 대한 IP 주소를 찾음
    - 브라우저가 202.43.78.3의 80 포트로 TCP 커넥션을 생성
    - 브라우저가 서버로 HTTP GET 요청 메세지를 보냄
    - 브라우저가 서버에서 온 HTTP 응답 메세지를 읽음
    - 브라우저가 커넥션을 끊음

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- HTTP 커넥션은 몇몇 사용 규칙을 제외하고는 TCP 커넥션에 불과

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송

- TCP는 IP패킷이라고 불리는 작은 조각을 통해 데이터를 전송
- HTTP는 IP, TCP, HTTP로 구성된 프로토콜 스택에서 최상위 계층
- HTTP에 보안 기능을 더한 HTTPS는 TLS 혹은 SSL이라고 불리기도 하며, HTTP TCP 사이에 있는 암호화 계층

|        프로토콜        |    계층     | 
|:------------------:|:---------:|
|        HTTP        | 애플리케이션 계층 |
|        TCP         |   전송 계층   |
|         IP         |  네트워크 계층  |
| Network Interfaces | 데이터링크 계층  |

|        프로토콜        |    계층     | 
|:------------------:|:---------:|
|        HTTP        | 애플리케이션 계층 |
|     TLS or SSL     |   보안 계층   |
|        TCP         |   전송 계층   |
|         IP         |  네트워크 계층  |
| Network Interfaces | 데이터링크 계층  |

- HTTP 메세지를 전송
    - TCO 커넥션을 통해 메세지 데이터의 내용을 순서대로 보냄
    - TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나눔
    - IP 패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달
        - IP 패킷 헤더 (보통 20 바이트)
        - TCP 세그먼트 헤더 (보통 20바이트)
        - TCP 데이터 조각 (0 혹은 그 이상 바이트)

### 4.1.3 TCP 커넥션 유지하기

- 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있음
- TCP 포트 번호를 통해 여러 개의 커넥션을 유지
- <발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>
- 4가지 커넥션 구성요소를 모두 똑같이 가리키는 커넥션은 있을 수 없음

### 4.1.4 TCP 소켓 프로그래밍

- 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능 제공
- 소켓 API는 유닉스 운영체제용으로 먼저 개발
- TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 일고 쓸 수 있음
- 소켓 순서 (s: 서버, c: 클라이언트)
  - s1: 새로운 소켓을 만듬
  - s2: 80 포트로 소켓을 묶음
  - s3: 소켓 커넥션을 허가
  - s4: 커넥션을 기다림
  - c1: ip 주소와 포트를 얻음
  - c2: 새로운 소켓을 생성
  - c3: 서버의 IP 포트로 연결
  - s5: 애플리케이션 커넥션 통지
  - s6: 요청을 읽기 시작
  - c4: 성공적으로 연결
  - c5: HTTP 요청을 보냄
  - c6: HTTP 응답을 기다림
  - s7: HTTP 요청 메세지를 처리 
  - s8: HTTP dmdekqdmf qhsoa
  - c7: HTTP 응답을 처리함 
  - s8: 커넥션을 닫음
  - c8: 커넥션을 닫음

<br>

## 4.2 TCP 성능에 대한 고려

### 4.2.1 HTTP 트랜잭션 지연
- 트랜잭션을 처리하는 시간은 TCP 커넥션을 설정하고, 요청을 전성하고, 응답 메세지를 보내는 것에 비해 매우 적음
- 대부분 HTTP 지연은 네트워크 지연으로 발생
- HTTP 트랜잭션 지연시키는 원인
  - 클라이언트는 URI에서 웹 서버의 IP 주소와 포트 번호를 알아내야 함
    - URI에 기술되어 있는 호스트에 방문한 적이 없으면 DNS 이름 분석 인프라를 사용하여 호스트 명을 IP 주소로 변환
  - 클라이언트는 TCP 커넥션 요청을 서버에게 보내고 서버가 커넥션 허가 응답을 회신하기를 기다림
    - 커넥션 설정 시간은 새로운 TCP 커넥션에서 항상 발생
  - 커넥션이 맺어지면 클라이언트는 HTTP 요청을 새로 생성된 TCP 파이프를 통해 전송
    - 웹 서버는 데이ㅓ가 도착하는 대로 TCP 커넥션에서 요청 메세지를 읽고 처리
- 웹서버가 HTTP 응답을 보내는 것 역시 시간 소요


### 4.2.3 TCP 커넥션의 핸드셰이크 설정
- 어떤 데이터를 전송하든 새로운 TCP 커넥션을 열 때면 연속으로 IP 패킷을 교환
- 작은 패킷 교환은 HTTP 성능을 크게 저하 시킴
  - TCP 핸드셰이크
    - 클라이언트는 새로운 TCP 커넥션을 생성하기 위해 작은 TCP 패킷(보통 40~60바이트)를 서버에 보냄
      - SYN라는 특별한 플래그 -> 커넥션 생성 요청
    - 서버가 그 커넥션을 받으면 몇 가지 커넥션 매개변수를 산출하고 커넥션 요청이 받아졌음을 의미
      - SYN, ACK 플래그를 포함한 TCP 패킷을 클라이언트에게 보냄
    - 마지막으로 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해 서버에게 다시 확인 응답을 보냄
- HTTP 트랜잭션이 아주 큰 데이터를 주고받지 않는 평범한 경우에는 눈에 띄는 지연을 발생
- 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP를 구성하는데 씀

### 4.2.4 확인응답 지연
- 인터넷 자체가 패킷 전송을 완벽히 보장하지 않으므로 TCP는 데이터 전송을 보장하기 위해 자체적인 확인 체계를 가짐
- 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가짐
- 각 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인 패킷을 송신자에게 반환
  - 특정 시간내에 받지 못하면, 패킷이 파기 or 오류 -> 데이ㅓ를 다시 전송
- 확인 응답은 그 크기가 작기 때문에, TCP는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 편승 시킴
- 편승되는 경우를 늘리기 위해 **확인응답 지연** 알고리즘을 구현
- 확인응답 지연은 송출할 확인응답을 특정 시간 동안 버퍼에 저장
- 확인응답을 편승시키기 위한 송출 데이터 패킷을 찾음
- HTTP 동장 방식 -> 확인 응답이 송출 데이터 패킷에 편승할 기회를 감소시킴
  - 편승할 패킷을 찾으려고 하면, 해당 방향으로 송출될 패킷이 많지 않음

### 4.2.5 TCP 느린 시작
- TCP 커넥션이 만들어진 지 얼마나 지났는지에 따라 전송속도가 달라짐
  - 처음에는 커넥션의 최대 속도를 제한 ~> 속도 제한을 높임
- 혼잡제어 기능 -> 새로운 커넥션은 이미 어느 정도 데이터를 주고받은 튜닝된 커넥션보다 느림
- 튜닝된 커넥션은 더 빠르기 때문에 HTTP는 이미 존재하는 커넥션을 재사용하는 기능

### 4.2.6 네이글 알고리즘과 TCP_NODELAY
- 애플리케이션이 어떤 크기의 데이터든 TCP 스택으로 전송할 수 있도록, TCP는 데이터 스트림 인터페이스를 제공
- 각 TCP 세그먼트는 40바이트 상당의 플래그와 헤더를 포함하여 전송 -> 작은 크기의 데이터를 가진 많은 수의 패킷 전송 ~> 성능 하락
- 네이글 알고리즘은 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한 개의 덩어리로 합침
- 세그먼트가 최대 크기 (약 1500 바이트 정도)가 되지 않으면, 전송을 하지 않음
- 모든 패킷이 확인응답을 받았을 경우에는 최대 크기보다 작은 패킷의 전송을 허락
- 전송되고 나서 확인응답을 기다리던 패킷이 확인응답을 받았거나 전송하기 충분할 만큼의 패킷이 쌓였을 때 버퍼에 저장되어 있던 데이터가 전송
- 크기가 작은 HTTP 메세지는 패킷을 채우지 못하기 때문에 앞으로 생기지 않을지 모르는 추가적인 데이터를 기다리며 지연
- 확인응답 지연가 함께 쓰일 경우 -> 악화
- TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘 비활성화
  - 작은 크기의 패킷이 너무 많이 생기지 않도록 큰 크기의 데이터 덩어리를 만들어야 함

### 4.2.7 TIME_WAIT의 누적과 포트 고갈
- TIME_WAIT 포트 고갈은 성능 측정 시에 심각한 성능 저하 발생
- TCP 커넥션의 종단에서 TCP 커넥션을 끊으면 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어 영역에 기록
- 같은 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정 시간 동안에는 생성되지 않게 하기 위한 것
- 최대 생명주기에 두 배 정도의 시간동안만 유지
- 이전 커넥션과 과녈ㄴ된 패킷이 그 커넥션과 가은 주소와 포트 번호를 가지는 새로운 커넥션에 삽입되는 문제를 방지

<br>

## 4.3 HTTP 커넥션 관리

### 4.3.1 흔히 잘못 이해하는 Connection 헤더
- HTTP는 클라이언트와 서버 사이에 프락시 서버, 캐시 서버 등과 같은 중개 서버가 놓이는 것을 허락
- HTTP 메세지는 클라이언트에서 서버까지 중개 서버들을 하나하나 거치면서 전달
- HTTP Connection 헤더 필드는 커넥션 토큰을 쉼표로 구분하여 가지고 있음
  - 그 값들은 다른 커넥션에 전달되지 않음
- 다음 메세지를 보낸 다음 끊어져야 할 커넥션은 Connection: close라고 명시
- HTTP 헤더 필드 명은, 이 커넥션에만 해당되는 헤더들을 나열
- 임시적인 토큰 값은, 커넥션에 대한 비표준 옵션을 의미
- close 값은, 커넥션이 작업이 완료되면 종료되어야 함
- 커넥션 토큰이 HTTP 헤더 필드명을 가지고 있으면, 해당 필드들은 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안됨
- Connection에 있는 모든 헤더 필드는 메세지를 다른 곳으로 전달하는 시점에 삭제되어야 함
- Connection 헤더에는 홉별 헤더명을 기술 -> 헤더 보호하기

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연
- 커넥션 관리가 제대로 이뤄지지 않으면 TCP 성능이 매우 안 좋아질 수 있음
- 순차 로드 방식은 특정 브라우저의 경우 객체를 화면에 배치하려면 객체의 크기를 알아야 함
  - 모든 객체를 내려받기 전까지는 텅 빈 화면을 보여줌
- HTTP 커넥션의 성능을 향상 시킬 수 있는 최신 기술 존재

<br>

### 4.4 병렬 커넥션

- HTTP 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리 가능

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받음
- 단일 커넥션의 대역폭 제한과 커넥션이 동작하지 않고 있는 시간을 활용하면, 객체가 여러 개 있는 웹페이즈를 더 빠르게 내려받을 수 있음
- 하나의 커넥션으로 객체들을 로드할 때, 대역폭 제한과 대기 시간을 줄일 수 있다면 더 빠르게 로드할 수 있음
- 각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있음
- 클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 써버리는 것이 아니라면 나머지 객체를 내려받는 데에 남은 대역폭 사용

### 4.4.2 병렬 커넥션이 항상 빠르지는 않음
- 병렬 커넥션이 일반적으로 더 빠르기는 하지만, 항상 그렇지는 않음
- 틀라이언트의 네트워크 대역폭이 좁을 때, 대부분의 시간을 데이터를 전송하는데만 쓰임
- 여러 개의 객체를 병렬로 내려받는 경우 -> 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 성능상의 장점은 거의 없어짐
- 다수의 커넥션은 메모리르 많이 소모, 자체적인 성능 문제 발생
- 복잡한 웹페이지는 수십 개에서 수 백 개의 객체를 포함
- 클라이언트가 수백 개의 커넥션을 열 수도 있겠지만, 서버는 다른 여러 사용자의 요청도 함께 처리해야 하기 대문에 수백 개의 커넥션을 허용하는 경우는 드뭄
- 백 명의 가상 사용자가 각각 100개의 커넥션을 맺고 있다면, 서버는 총 10,000개의 커넥션을 떠안게 됨
- 브라우저는 실제로 병렬 커넥션을 사용하긴 하지만, 적은 수의 병렬 커넥션만 허용

### 4.4.3 병렬 커넥션은 더 빠르게 느껴질 수 있음
- 병렬 커넥션이 페이지를 항상 더 빠르게 로드하지는 않음
- 웹 클라이언트는 같은 사이트에 여러 개의 커넥션을 맺음
- 웹 페이지에 첨부된 이미지들 대부분은 같은 웹사이트에 있음
- 지역성
- 이미 맺어져 있는 지속 커넥션을 사용함으로써, 커넥션을 맺기 위한 준비작업에 따르는 시간을 절약할 수 있음
- 비지속 커넥션은 각 처리가 끝날 때마다 커넥션응ㄹ 끊지만, 지속 커넥션은 클라이언트나 서버가 커넥션을 끊기전까지 트랜잭션 간에도 커넥션 유지
- 해당 서버에 이미 맺어져 있는 지속 커넥션을 재사용 -> TCP의 느린 시작으로 인한 지연을 피함


### 4.5.1 지속 vs 병렬
- 병렬 커넥션은 여러 객체가 있는 페이지를 더 빠르게 전송
  - 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요
  - 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어짐
  - 실제로 연결할 수 있는 병렬 커넥션 수에는 제한이 있음
- 지속 커넥션은 병렬 커넥션과 함께 사용될 때 가장 효과적

### 4.5.2 HTTP/1.0 keep-alive 커넥션
- 연속적으로 네 개의 커넥션을 생성하여 처리하는 방식과 하나의 지속 커넥션으로만 처리하는 방식
- keep-alive 커넥션을 맺고 끊는데 필요한 작업이 없어서 시간 단축

### 4.5.4 Keep-alive 옵션
- Keep-alive 헤더는 커넥션을 유지하기 바라는 요청
- 클라이언트나 서버가 keep-alive를 받았다고해서 그것을 따를 필요는 없음
- 언제든지 커넥션을 끊을 수 있음
  - timeout parameter는 keep-alive 응답 헤더를 통해 보냄
  - 커넥션이 얼마간 유지될 것인가를 의미
  - max 파라미터는 keep-alive 응답 헤더를 통해 보냄
  - 커넥션이 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지를 의미
  - Keep-alive 헤더는 진단이나 디버깅을 주목적으로 하는, 처리되지 않는 임의의 속성을을 지원하기도 함
- keep-alive 헤더 사용은 선택 사항
  - Connection; Keep-Alive 헤더가 있을 때만 사용 가능

### 4.5.5 Keep-Alive 커넥션 제한과 규칙
- keep-alive는 Http/1.0에서 기본 사용 x
- 커넥션을 계속 유지하려면 모든 메세지에 connection: Keep-alive 헤더를 포함해야 함
- 커넥션이 끊어지기 전에 엔티티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있음
- 엔티티 본문이 정확한 Content-Length 값과 함께 멀티파트 미디어 형식을 가지거나 청크 전송 인코딩으로 인코드 되어야 함
- keep-alive 커넥션에서 잘못된 Content-Length 값을 보내는 것은 좋지 않은데, 트랜잭션이 끝나는 시점에 기존 메세지의 끝과 새로운 메세지의 시작점을 정확히 알 수 없음
- 프락시와 게이트웨이는 Connection 헤더의 규칙을 철저히 지켜야 함
  - 멍청한 프록시

### 4.5.6 Keep-Alive와 멍청한 프록시
- Connection Header의 무조건 전달
  - 프록시는 Connection 헤더를 이해하지 못해 해당 헤더를 삭제하지 않고 요청 그대로 프록시에 전달
  - 웹 클라이언트는 프록시에 Connection: Keep-Alive 헤더와 함께 메세지를 보냄
  - 커넥션을 유지하기를 희망하고 응답을 기다림
  - 멍청한 프록시는 요청받은 HTTP Connection 헤더를 이해하지 못함
  - Connection 헤더는 홉별 헤더(오직 한 개의 전송 링크에만 적용, 다음 서버로 전달되어서는 안됨)
  - 전달된 HTTP 요청이 서버에 도착
  - 웹 서버가 프락시로부터 Connection: Keep-Alive 헤더를 받으면 웹 서버는 프록시가 커넥션을 윶하자고 요청하는 것으로 잘못 판단
  - 웹 서버는 문제될 것이 없기 때문에 프록시와 커넥션을 유지하는 것에 동의
  - 웹 서버는 프록시와 keep-alive 커넥션이 맺어져 있는 상태로 통신
  - 클라이언트와 서버는 프록시를 중간에 두고 계속 keep-alive를 유지한채로 끊지 않고 대기
  - 타임아웃이 될 떄까지 상태가 유지되는 문제 발생
- 이런 종류의 통신을 피하기 위해서는 Connection 헤더와 Connection 헤더에 명시된 헤더는 절대 전달하면 안됨
- Connection 헤더의 값으로 명시되지 않는 Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade와 같은 홉별 헤더들 역시 전달하거나 캐시하면 안됨

### 4.5.7 Proxy-Connection
- 클라이언트의 요청이 중개서버를 통해 이어지는 경우 모든 헤더를 무조건 전달하는 문제를 피하기 위해 Proxy-Connection 개발
- 멍청한 프록시는 Connection: Keep-Alive와 같은 홉별 헤더를 무조건 전달하므로 문제 생김
- 홉별 헤더들은 한 개의 특정 커넥션에서 쓰이고 그 이후에 전달하면 안됨
- 홉별 헤더를 전달받은 서버가 그 헤더를 자신과 프록시 간의 커넥션에 대한 것으로 오해하면서 문제 생김
- 비표준인 Proxy-Connection 확장 헤더를 프락시에 전달
- 프록시는 Proxy-Connection을 무조건 전달하더라도 웹서버는 그것을 무시하기 때문에 별 문제가 되지 않음
- 영리한 프록시는 의미없는 헤더인 Proxy-Connection 헤더를 Connection 헤더로 바꿈으로써 원하는 효과를 얻게 됨
