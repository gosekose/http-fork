# 캐시

<br>

## 7.1 불필요한 데이터 전송

- 캐시를 이용하면, 첫번째 서버 응답은 캐시에 보관

## 7.2 대역폭 병목

- 캐시는 네트워크 병목을 줄여줌
- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공
- 클라이언트들이 서버에 접근할 때의 속도는 그 경로에 있는 가장 느린 네트워크 속도와 같음

## 7.4 거리로 인한 지연

- 대역폭이 문제가 되지 않더라도, 거리가 문제가 될 수 있음

## 7.5 적중과 부적중

- 캐시는 모든 사본을 저장하지 않음
- 캐시 요청이 도착했을 때, 그에 대응하는 사본이 있다면, 그를 이용해 요청이 처리될 수 있음
- 이를 캐시 적중
- 대응하는 사본이 없다면 원 서버로 전달 -> 캐시 부적중

### 7.5.1 재검사

- 원 서버 콘텐츠는 변경될 수 있기에 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 점검
- 신선도 검사를 HTTP 재검사라 부름
- 효과적인 재검사를 위해 HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청을 정의
- 캐시는 스스로 원한다면 언제든지 사본을 재검사
- 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사
- 신선도 검사에 대한 HTTP 규칙을 뒷 부분에서 설명
- 캐시는 캐시된 사본의 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보냄
- 콘텐츠가 변경되지 않았다면 304 Not Modified 응답을 보냄
- 그 사본이 여전히 유효함을 알게 된 캐시는 즉각 사본이 신선하다고 임시로 다시 표시한 뒤 그 사본을 클라이언트에게 제공
    - 재검사 적중 혹은 느린 적중
- 순수 캐시 적중보다 느린데, 원 서버와 검사를 할 필요가 있기 때문
- 캐시 부적중보다는 빠른데, 서버로부터 객체 데이터를 받아올 필요가 없기 때문
- HTTP는 캐시된 객체를 재확인하기 위한 몇 가지 도구 제공
- if-Modified-Since 헤더
    - 서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미
- GET if-Modified-Since 요청이 서버에 도착했을 때, 일어날 수 있는 상황
    - 재검사 적중
    - 재검사 부적중
    - 객체 삭제

### 7.5.2 적중률

- 캐시 적중률이 40%면 웹 캐시로 좋은 편

### 7.5.3 바이트 적중률

- 문서들이 모두 같은 크기인 것은 아님
- 적중률이 모든 것을 말해주지는 않음
- 어떤 사람들은 바이트 단위 적중률 측정값을 더 선호
- 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현
- 이 측정값은 트래픽이 절감된 정도를 포착해냄
- 바이트 단위 적중률 100%는 모든 바이트가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음
- 문서적중률과 바이트 단위 적중률은 둘 다 캐시 성능에 대한 유용한 지표
- 문서 적중률을 개선하면 전체 대기시간이 줄어 듬
- 바이트 단위 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여줌
- 바이트 단위 적중률의 개선은 대역폭 절약을 최적화

### 7.5.4 적증과 부적중의 구별

- 어떤 상용 프락시 캐시는 캐시에 무슨 일이 일어났는지 설명하기 위해 Via 헤더에 추가정보를 제공
- 클라이언트가 응답이 캐시에서 왔는지 알아내는 방법은 Date 헤더를 이용하는 것
- 클라이언트가 캐시된 응답을 감지하는 또 다른 방법은 응답이 얼마나 오래되었는지 말해주는 Age 헤더를 이용하는 것

## 7.6 캐시 토폴로지

- 캐시는 한 명의 사용자에게만 할당될 수도 있고 반대로 수천 명의 사용자들 간에 공유될 수 있음
- 한 명에게만 할당된 캐시를 전용 ㅐ시라 부름
- 개인 정용 캐시는 개인만을 위한 캐시이므로, 한 명의 사용자가 자주 찾는 페이지를 담음
- 공유된 캐시는 공용 캐시라고 부름
- 공용 캐시는 사용자 집단에게 자주 쓰이는 페이지를 담음

### 7.6.1 개인 전용 캐시

- 개인 전용 캐시는 많은 에너지나 저장 공간을 필요로 하지 않음

### 7.6.2 공용 프락시 캐시

- 공용 캐시는 캐시 프락시 서버 혹은 더 흔히 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버
- 프락시 캐시는 로컬 캐시에서 문서를 제공하거나 혹은 사용자 입장에서 서버에 접근
- 공용 캐시는 여러 사용자가 접근하기 때문에, 불필요한 트래픽을 줄일 수 있는 많은 기회가 있음

### 7.6.3 프락시 캐시 계층들

- 작은 캐시에서 부적중이 발생했을 때, 더 큰 부모 캐시가 걸러 남겨진 트래픽을 처리하도록 계층을 만드는 방법이 합리적

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

- 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만듬
- 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화
- 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션 결정을 동적으로 내림
- 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하고 서로를 찾아볼 수 있도록 함
- 선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불림
- 형제 캐시를 지원하지 않기 때문에 사람들은 인터넷 캐시 프로토콜이나 하이퍼텍스트 캐시 프로토콜과 같은 프로토콜을 이용해 HTTP를 확장

## 7.7 캐시 처리단계

- 요청 받기: 캐시는 네트워크로부터 도착한 요청 메세지를 읽음
- 파싱: 캐시는 메세지를 파싱하여 URL 헤더들을 추출
- 검색: 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아옴
- 신선도 검사: 캐시는 캐시된 사본이 충분히 신선한지 검사, 신선하지 않다면 변경사항이 있는지 서버에게 물어봄
- 응답 생성: 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려줌
- 로깅: 선택적으로는 캐시는 로그파일에 트랜잭션에 대한 서술한 로그 하나를 남김

### 7.7.1 요청 받기

- 캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어 들임
- 고성능 캐시는 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어 들임
- 메시지 전체가 도착하기 전에 트랜잭션 처리를 시도

### 7.7.2 파싱

- 캐시는 요청 메세지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담음
- 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만듬

### 7.7.3 검색

- 캐시는 URL을 알아내고, 그에 해당하는 로컬 사본이 있는지 검사
- 로컬 복사본은 메모리에 저장되어 있을 수도 있고, 디스크나 심지어 근처의 다른 컴퓨터에 있을 수도 있음
- 캐시된 객체는 서버 응답 본문과 원 서버의 응답 헤더를 포함
- 캐시 적중동안 올바른 서버 헤더가 반환될 수 있음
- 캐시된 객체는 또한 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지를 알려주는 기록이나 사용량을 메타데이터로 가짐

### 7.7.4 신선도 검사

- HTTP는 캐시가 일정 기간 동안 서버의 사본을 보유할 수 있도록 함
- 이 기간동안 문서는 신선한 것으로 간주
- 캐시는 서버와의 접촉 없이 이 문서를 제공할 수 있음
- 캐시된 사본을 신선도 한계를 넘을 정도로 너무 오래 갖고 있었다면 신선하지 않은 것을 ㅗ간주

### 7.7.5 응답 생성

- 캐시된 응답을 원 서버에서 보이게 하고 싶기 때문에, 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성

### 7.7.6 전송

- 응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 돌려줌
- 모든 프락시 서버들과 마찬가지로 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있음
- 고성능 캐시는 종종 로컬 저장장치와 네트워크 IO 버퍼 사이에서 문서의 콘텐츠 복사를 피함

### 7.7.7 로깅

## 7.8 사본을 신선하게 유지하기

### 7.8.1 문서 만료

- Cache-Control Expires라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효시간을 붙일 수 있게 함

### 7.8.3 서버 재검사

- 캐시된 문서가 만료되었다는 것은 문서가 바뀐 것을 의미하지는 않음 -> 재검사할 시간이 되었다는 것을 의미
- 문서가 변경된 경우 -> 새로운 사본을 가져와 데이터를 대신 저장한 후 클라이언트에게도 보냄
- 문서가 변경되지 않은 후, 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신

### 7.8.4 조건부 메서드와 재검사

- HTTP 조건무 메서드는 재검사를 효율적으로 만들어줌
- HTTP는 캐시가 서버에게 조건부 GET 이라는 요청을 보낼 수 있도록 함
- 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것
- 신선도 검사와 객체를 받아오는 것으 하나의 조건부 GET으로 결합
- If-Modified-Since (date)
    - 만약 문서가 주어진 날짜 이후로 수정되었다면, 요청 메서드를 처리
    - 캐시된 버전으로부터 콘텐츠가 변경된 경우에만 콘텐츠를 가져오기 위해 Last-Modified 서버 응답 헤더와 함께 사용
- If-None-Match tags:
    - 마지막 변경 날짜를 맞춰보는 대신, 서버는 문서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공
    - if-None-Match 헤더는 캐시된 태그가 서버에 있는 문서의 태그와 다를 때만 문서를 처리

### 7.8.5 If-Modified-Since

- IMS 요청으로 줄여 부름
- 문서가 주어진 날짜 이후로 변경 되었다면?
    - GET 요청 평범하게 수행
    - 새문서가, 새로운 만료 날짜와 그 외 다른 정보들이 담긴 헤더들과 함께 캐시에게 반환
- 문서가 주어진 날짜 이후에 변경되지 않았다면?
    - 304 Not Modified 제공
    - 효율을 위해 본문은 보내지 않음
- If-Modified-Since 헤더는 서버 응답 헤더의 Last-Modified 헤더와 함께 동작
    - 원 서버는 제공하는 문서에 최근 변경 일시를 붙임
    - 캐시가 캐시된 문서를 재검사 하려고 할 대, 캐시된 사본이 마지막으로 수정된 날짜가 담긴 If-Modified-Since 헤더를 포함

### 7.8.6 If-None-Match

- 어떤 문서는 일정 시간 간격으로 다시 쓰여지지만, 실제로는 같은 데이터를 포함 내용에는 아무런 변화가 없더라도 변경시각은 바뀔 수 있음
- 어떤 문서들의 변경은 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것일 수 있음
- 어떤 서버들은 그들이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없음
- 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는 변경일에 대한 1초의 정밀도는 충분하지 않을 수 있음

## 7.9 캐시 제어

- Cache-Control
    - no-store
    - no-cache
    - must-revalidate
    - max-age
- Expires
- 아무 만료 정보를 제공하지 않고 캐시가 스스로 휴리스틱한 방법으로 결정

### 7.9.1 no-chche와 no-store 헤더

- 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막음
- no-store는 캐시가 그 응답의 사본을 만드는 것을 금지
- no-cache로 표시된 응답은 사실 로컬 캐시 저장소에 저장될 수 있음
- 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐

### 7.9.2 Max-Age 응답 헤더

- Cache-Control: max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간, 초 단위로 표현
- s-maxage 헤더는 캐시에만 적용

### 7.9.3 Expires 응답 헤더

- 더 이상 사용하지 않기를 권하는 Expires 헤더는 만료 날짜를 명시

### 7.9.6 클라이언트의 신선도 제약

- 웹브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜주는 리프레시나 리로드 버튼
- Cache-Control 요청 헤더가 추가된 GET 요청을 발생시켜, 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져옴
- 